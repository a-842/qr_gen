{% extends 'base.html' %}

{% block head %}
{% endblock %}

{% block body %}

<div id="sidebar">
        <h3>Help Documents</h3>
        <a href="#" onclick="loadContent('Versions')">Picking a Version</a>
        <a href="#" onclick="loadContent('RSec')">Reed-Solomon Encoding</a>
        <a href="#" onclick="loadContent('BCH')">BCH Encoding</a>
</div>
    <div id="content">
        <h2>Welcome</h2>
        <p>Select a topic from the sidebar.</p>
    </div>

    <script>
        const contentMap = {
            'Versions': '<h1>QR Code Version</h1><p>When deciding what version/size of QR code to use, we look through pre-defined tables depending on the parameters required.</p><p>Say in this example you are  working out what version of QR Code to use for <b>Numerical</b> data with <b>Quartile</b> error correction and you data was <b>60 Characters</b> long.</p><ol><li>Find the relavent table (Numeric Mode)</li><li>Find the relevant column of said table. (Highlighted in blue)</li><li>Look through the values to see which is the smallest Version that has more available data storage than we need (Highlighted in dark blue)</li><li>Once we have the version, we can use the formular <b>17 + (Version * 4)</b> to get the size.</li></ol><h2>Numeric Mode</h2> <table> <tr> <th>Version</th><th>L</th><th>M</th><th>Q</th><th>H</th> </tr> <tr><td>1</td><td>41</td><td>34</td><td class="highlight-column">27</td><td>17</td></tr> <tr><td>2</td><td>77</td><td>63</td><td class="highlight-column">48</td><td>34</td></tr> <tr><td class="highlight-cell">3</td><td>127</td><td>101</td><td class="highlight-cell">77</td><td>58</td></tr> <tr><td>4</td><td>187</td><td>149</td><td class="highlight-column">111</td><td>82</td></tr> <tr><td>5</td><td>255</td><td>202</td><td class="highlight-column">144</td><td>106</td></tr> <tr><td>6</td><td>322</td><td>255</td><td class="highlight-column">178</td><td>139</td></tr> <tr><td>7</td><td>370</td><td>293</td><td class="highlight-column">207</td><td>154</td></tr> <tr><td>8</td><td>461</td><td>365</td><td class="highlight-column">259</td><td>202</td></tr> <tr><td>9</td><td>552</td><td>432</td><td class="highlight-column">312</td><td>235</td></tr> <tr><td>10</td><td>652</td><td>513</td><td class="highlight-column">364</td><td>288</td></tr> </table> <h2>Alphanumeric Mode</h2> <table> <tr> <th>Version</th><th>L</th><th>M</th><th>Q</th><th>H</th> </tr> <tr><td>1</td><td>25</td><td>20</td><td>16</td><td>10</td></tr> <tr><td>2</td><td>47</td><td>38</td><td>29</td><td>20</td></tr> <tr><td>3</td><td>77</td><td>61</td><td>47</td><td>35</td></tr> <tr><td>4</td><td>114</td><td>90</td><td>67</td><td>50</td></tr> <tr><td>5</td><td>154</td><td>122</td><td>87</td><td>64</td></tr> <tr><td>6</td><td>195</td><td>154</td><td>108</td><td>84</td></tr> <tr><td>7</td><td>224</td><td>178</td><td>125</td><td>93</td></tr> <tr><td>8</td><td>279</td><td>221</td><td>157</td><td>122</td></tr> <tr><td>9</td><td>335</td><td>262</td><td>189</td><td>143</td></tr> <tr><td>10</td><td>395</td><td>311</td><td>221</td><td>174</td></tr> </table> <h2>Byte Mode</h2> <table> <tr> <th>Version</th><th>L</th><th>M</th><th>Q</th><th>H</th> </tr> <tr><td>1</td><td>17</td><td>14</td><td>11</td><td>7</td></tr> <tr><td>2</td><td>32</td><td>26</td><td>20</td><td>14</td></tr> <tr><td>3</td><td>53</td><td>42</td><td>32</td><td>24</td></tr> <tr><td>4</td><td>78</td><td>62</td><td>46</td><td>34</td></tr> <tr><td>5</td><td>106</td><td>84</td><td>60</td><td>44</td></tr> <tr><td>6</td><td>134</td><td>106</td><td>74</td><td>58</td></tr> <tr><td>7</td><td>154</td><td>122</td><td>86</td><td>64</td></tr> <tr><td>8</td><td>192</td><td>152</td><td>108</td><td>84</td></tr> <tr><td>9</td><td>230</td><td>180</td><td>130</td><td>98</td></tr> <tr><td>10</td><td>271</td><td>213</td><td>151</td><td>119</td></tr> </table>',
            'RSec': '<h1>Error Correction of the Main Data</h1><p>This tool uses a third-party algorithm to calculate the Reed-Solomon error correction in this step, so I dont know enough to write a good document on the subject. Here are some links that I found helpful when learning.<ul><li><a href="https://tomverbeure.github.io/2022/08/07/Reed-Solomon.html">https://tomverbeure.github.io/2022/08/07/Reed-Solomon.html</a></li><li><a href="https://www.youtube.com/watch?v=fBRMaEAFLE0">https://www.youtube.com/watch?v=fBRMaEAFLE0</a></li></ul></p>',
            'BCH': '<h1>Error Correction in QR Code Format Information</h1> <p>The error correction mechanism for QR code format information ensures that the encoded data (error correction level and mask pattern) can be accurately recovered even if the QR code is damaged or tampered with.  It does this using a BCH (Bose–Chaudhuri–Hocquenghem) Code, and this document explains the process, including encoding, tampering, and decoding, with an example.</p> <h2>Encoding Process</h2> <h3>Input Data</h3> <ul> <li><strong>Error Correction (EC) Bits</strong>: 2 bits representing the error correction level (e.g., <code>01</code> for Medium).</li> <li><strong>Mask Bits</strong>: 3 bits indicating the mask pattern (e.g., <code>011</code> for Mask 3).</li> <li><strong>Combined Bits</strong>: Concatenate EC and mask bits (<code>01</code> + <code>011</code> = <code>01011</code>).</li> </ul> <h3>Polynomial Division</h3> <ul> <li><strong>Generator Polynomial</strong>: <code>0b10100110111</code> (11 bits).</li> <li>Convert <code>combined_bits</code> to an integer and shift left by 10 bits to create space for error correction bits.</li> <li>Perform polynomial division using the generator to compute a 10-bit <strong>remainder</strong> (error correction code).</li> </ul> <h3>Format Bits Construction</h3> <ul> <li>Combine the original <code>combined_bits</code> (shifted left) with the computed 10-bit remainder.</li> <li>XOR the result with a fixed <strong>mask pattern</strong> (<code>0b101010000010010</code>) to produce the final 15-bit format string.</li> </ul> <h2>Example: Encoding</h2> <h3>Input</h3> <ul> <li>EC Level: <code>01</code> (Medium)</li> <li>Mask ID: <code>011</code> (Mask 3)</li> <li>Combined Bits: <code>01011</code></li> </ul> <h3>Polynomial Division</h3> <pre> Shift 01011 by 10 bits: 010110000000000 Divide by 0b10100110111 to compute remainder: 0000101001 (41 in decimal) </pre> <h3>Final Format String</h3> <pre> 0101100000101001 XOR 101010000010010 ----------------- 111100000001101 </pre> <p><strong>Encoded Output</strong>: <code>111100000001101</code></p> <h2>Tampering Example</h2> <p>Suppose the encoded format string <code>111100000001101</code> is tampered with, flipping the last bit:</p> <p><strong>Tampered String</strong>: <code>111100000001100</code></p> <h2>Decoding Process</h2> <h3>Recovery</h3> <pre> 111100000001100 XOR 101010000010010 ----------------- 010110000011110 </pre> <p>Split into <code>combined_bits</code> (<code>01011</code>) and corrupted error bits (<code>0000011110</code>).</p> <h3>Error Detection</h3> <p>Recompute the expected error bits using <code>01011</code> and polynomial division (original remainder: <code>0000101001</code>).</p> <p>Compare with corrupted error bits (<code>0000011110</code>). The mismatch indicates errors.</p> <h3>Error Correction</h3> <p>The BCH code corrects up to 3 errors. By analyzing discrepancies, the decoder identifies and flips the erroneous bit (last bit).</p> <h3>Corrected Output</h3> <p>After correction, the original format string <code>111100000001101</code> is restored.</p> <h2>Summary</h2> <p>This error correction method ensures QR codes remain readable despite partial damage. By encoding redundancy (error correction bits) and using XOR with a mask pattern, errors can be detected and corrected during decoding. The example demonstrates resilience against tampering, highlighting the robustness of QR code format information.</p>',

        };

        function loadContent(section) {
            document.getElementById('content').innerHTML = contentMap[section];
        }
    </script>

{% endblock %}
