{% extends 'base.html' %}

{% block head %}
{% endblock %}

{% block body %}

<div id="sidebar">
        <h3>Help Documents</h3>
        <a href="#" onclick="loadContent('Versions')"><button>Picking a Version</button></a>
        <a href="#" onclick="loadContent('RSec')"><button>Reed-Solomon Encoding</button></a>
        <a href="#" onclick="loadContent('BCH')"><button>BCH Encoding</button></a>
        <a href="#" onclick="loadContent('Masks')"><button>Mask Evaluation</button></a>
</div>
    <div id="content">
        <h2>Welcome</h2>
        <p>Select a topic from the list above.</p>
    </div>

    <script>
        const contentMap = {
            'Versions': '<h1>QR Code Version</h1><p>When deciding what version/size of QR code to use, we look through pre-defined tables depending on the parameters required.</p><p>Say in this example you are  working out what version of QR Code to use for <b>Numerical</b> data with <b>Quartile</b> error correction and you data was <b>60 Characters</b> long.</p><ol><li>Find the relavent table (Numeric Mode)</li><li>Find the relevant column of said table. (Highlighted in blue)</li><li>Look through the values to see which is the smallest Version that has more available data storage than we need (Highlighted in dark blue)</li><li>Once we have the version, we can use the formular <b>17 + (Version * 4)</b> to get the size.</li></ol><h2>Numeric Mode</h2> <table> <tr> <th>Version</th><th>L</th><th>M</th><th>Q</th><th>H</th> </tr> <tr><td>1</td><td>41</td><td>34</td><td class="highlight-column">27</td><td>17</td></tr> <tr><td>2</td><td>77</td><td>63</td><td class="highlight-column">48</td><td>34</td></tr> <tr><td class="highlight-cell">3</td><td>127</td><td>101</td><td class="highlight-cell">77</td><td>58</td></tr> <tr><td>4</td><td>187</td><td>149</td><td class="highlight-column">111</td><td>82</td></tr> <tr><td>5</td><td>255</td><td>202</td><td class="highlight-column">144</td><td>106</td></tr> <tr><td>6</td><td>322</td><td>255</td><td class="highlight-column">178</td><td>139</td></tr> <tr><td>7</td><td>370</td><td>293</td><td class="highlight-column">207</td><td>154</td></tr> <tr><td>8</td><td>461</td><td>365</td><td class="highlight-column">259</td><td>202</td></tr> <tr><td>9</td><td>552</td><td>432</td><td class="highlight-column">312</td><td>235</td></tr> <tr><td>10</td><td>652</td><td>513</td><td class="highlight-column">364</td><td>288</td></tr> </table> <h2>Alphanumeric Mode</h2> <table> <tr> <th>Version</th><th>L</th><th>M</th><th>Q</th><th>H</th> </tr> <tr><td>1</td><td>25</td><td>20</td><td>16</td><td>10</td></tr> <tr><td>2</td><td>47</td><td>38</td><td>29</td><td>20</td></tr> <tr><td>3</td><td>77</td><td>61</td><td>47</td><td>35</td></tr> <tr><td>4</td><td>114</td><td>90</td><td>67</td><td>50</td></tr> <tr><td>5</td><td>154</td><td>122</td><td>87</td><td>64</td></tr> <tr><td>6</td><td>195</td><td>154</td><td>108</td><td>84</td></tr> <tr><td>7</td><td>224</td><td>178</td><td>125</td><td>93</td></tr> <tr><td>8</td><td>279</td><td>221</td><td>157</td><td>122</td></tr> <tr><td>9</td><td>335</td><td>262</td><td>189</td><td>143</td></tr> <tr><td>10</td><td>395</td><td>311</td><td>221</td><td>174</td></tr> </table> <h2>Byte Mode</h2> <table> <tr> <th>Version</th><th>L</th><th>M</th><th>Q</th><th>H</th> </tr> <tr><td>1</td><td>17</td><td>14</td><td>11</td><td>7</td></tr> <tr><td>2</td><td>32</td><td>26</td><td>20</td><td>14</td></tr> <tr><td>3</td><td>53</td><td>42</td><td>32</td><td>24</td></tr> <tr><td>4</td><td>78</td><td>62</td><td>46</td><td>34</td></tr> <tr><td>5</td><td>106</td><td>84</td><td>60</td><td>44</td></tr> <tr><td>6</td><td>134</td><td>106</td><td>74</td><td>58</td></tr> <tr><td>7</td><td>154</td><td>122</td><td>86</td><td>64</td></tr> <tr><td>8</td><td>192</td><td>152</td><td>108</td><td>84</td></tr> <tr><td>9</td><td>230</td><td>180</td><td>130</td><td>98</td></tr> <tr><td>10</td><td>271</td><td>213</td><td>151</td><td>119</td></tr> </table>',
            'RSec': '<h1>Error Correction of the Main Data</h1><p>This tool uses a third-party algorithm to calculate the Reed-Solomon error correction in this step, so I dont know enough to write a good document on the subject. Here are some links that I found helpful when learning.<ul><li><a href="https://tomverbeure.github.io/2022/08/07/Reed-Solomon.html">https://tomverbeure.github.io/2022/08/07/Reed-Solomon.html</a></li><li><a href="https://www.youtube.com/watch?v=fBRMaEAFLE0">https://www.youtube.com/watch?v=fBRMaEAFLE0</a></li></ul></p>',
            'BCH': '<h1>Error Correction in QR Code Format Information</h1> <p>The error correction mechanism for QR code format information ensures that the encoded data (error correction level and mask pattern) can be accurately recovered even if the QR code is damaged or tampered with.  It does this using a BCH (Bose–Chaudhuri–Hocquenghem) Code, and this document explains the process, including encoding, tampering, and decoding, with an example.</p> <h2>Encoding Process</h2> <h3>Input Data</h3> <ul> <li><strong>Error Correction (EC) Bits</strong>: 2 bits representing the error correction level (e.g., <code>01</code> for Medium).</li> <li><strong>Mask Bits</strong>: 3 bits indicating the mask pattern (e.g., <code>011</code> for Mask 3).</li> <li><strong>Combined Bits</strong>: Concatenate EC and mask bits (<code>01</code> + <code>011</code> = <code>01011</code>).</li> </ul> <h3>Polynomial Division</h3> <ul> <li><strong>Generator Polynomial</strong>: <code>0b10100110111</code> (11 bits).</li> <li>Convert <code>combined_bits</code> to an integer and shift left by 10 bits to create space for error correction bits.</li> <li>Perform polynomial division using the generator to compute a 10-bit <strong>remainder</strong> (error correction code).</li> </ul> <h3>Format Bits Construction</h3> <ul> <li>Combine the original <code>combined_bits</code> (shifted left) with the computed 10-bit remainder.</li> <li>XOR the result with a fixed <strong>mask pattern</strong> (<code>0b101010000010010</code>) to produce the final 15-bit format string.</li> </ul> <h2>Example: Encoding</h2> <h3>Input</h3> <ul> <li>EC Level: <code>01</code> (Medium)</li> <li>Mask ID: <code>011</code> (Mask 3)</li> <li>Combined Bits: <code>01011</code></li> </ul> <h3>Polynomial Division</h3> <pre>Shift 01011 by 10 bits: 010110000000000\nDivide by 0b10100110111 to compute remainder: 0000101001 (41 in decimal) </pre> <h3>Final Format String</h3> <pre>0101100000101001\nXOR\n101010000010010\n-----------------\n111100000001101 </pre> <p><strong>Encoded Output</strong>: <code>111100000001101</code></p> <h2>Tampering Example</h2> <p>Suppose the encoded format string <code>111100000001101</code> is tampered with, flipping the last bit:</p> <p><strong>Tampered String</strong>: <code>111100000001100</code></p> <h2>Decoding Process</h2> <h3>Recovery</h3> <pre>\n111100000001100\nXOR\n101010000010010\n-----------------\n010110000011110</pre> <p>Split into <code>combined_bits</code> (<code>01011</code>) and corrupted error bits (<code>0000011110</code>).</p> <h3>Error Detection</h3> <p>Recompute the expected error bits using <code>01011</code> and polynomial division (original remainder: <code>0000101001</code>).</p> <p>Compare with corrupted error bits (<code>0000011110</code>). The mismatch indicates errors.</p> <h3>Error Correction</h3> <p>The BCH code corrects up to 3 errors. By analyzing discrepancies, the decoder identifies and flips the erroneous bit (last bit).</p> <h3>Corrected Output</h3> <p>After correction, the original format string <code>111100000001101</code> is restored.</p> <h2>Summary</h2> <p>This error correction method ensures QR codes remain readable despite partial damage. By encoding redundancy (error correction bits) and using XOR with a mask pattern, errors can be detected and corrected during decoding. The example demonstrates resilience against tampering, highlighting the robustness of QR code format information.</p>',
            'Masks': '<h1><h1>QR Code Mask Penalties</h1> <p>QR codes use mask patterns to optimize readability and error correction. Each mask pattern is evaluated using a set of rules to determine its suitability. This document explains the evaluation process, including the rules and how penalties are calculated. It also provides an example of how a QR code mask is scored.</p> <h2>Mask Evaluation Overview</h2> <p>The evaluation process assigns a penalty score to a QR code based on its structure and content. The goal is to minimize this score, as lower penalties indicate better readability and robustness. The evaluation is based on four rules:</p> <h3>Rule 1: Consecutive Same-Color Modules</h3> <p>Penalizes long sequences of the same color in rows or columns.</p> <h3>Rule 2: 2x2 Blocks of Same-Color Modules</h3> <p>Penalizes 2x2 blocks of the same color.</p> <h3>Rule 3: Specific Patterns</h3> <p>Penalizes the presence of patterns like <code>1011101</code> in rows or columns.</p> <h3>Rule 4: Balance of Black and White Modules</h3> <p>Penalizes QR codes with an unbalanced ratio of black to white modules.</p> <p>The total penalty is the sum of penalties from all four rules.</p><hr><h2>Evaluation Rules in Detail</h2> <h3>Rule 1: Consecutive Same-Color Modules</h3> <p><strong>Objective:</strong> Avoid long sequences of the same color in rows or columns.</p> <h4>Penalty Calculation:</h4> <ol> <li>For every sequence of 5 or more consecutive modules of the same color, add a penalty of 3 + (length - 5).</li> </ol> <p><strong>Example:</strong> A sequence of 7 black modules incurs a penalty of <code>3 + (7 - 5) = 5</code>.</p> <h3>Rule 2: 2x2 Blocks of Same-Color Modules</h3> <p><strong>Objective:</strong> Avoid 2x2 blocks of the same color.</p> <h4>Penalty Calculation:</h4> <ol> <li>For every 2x2 block of the same color, add a penalty of 3.</li> </ol> <h3>Rule 3: Specific Patterns</h3> <p><strong>Objective:</strong> Avoid specific patterns (<code>1011101</code> or its reverse) in rows or columns.</p> <h4>Penalty Calculation:</h4> <ol> <li>For every occurrence of the pattern 1011101, add a penalty of 40.</li> </ol> <h3>Rule 4: Balance of Black and White Modules</h3> <p><strong>Objective:</strong> Ensure a balanced ratio of black to white modules.</p> <h4>Penalty Calculation:</h4> <ol> <li>Calculate the percentage of black modules.</li> <li>Find the nearest multiple of 5 to this percentage.</li> <li>Compute the absolute difference between this multiple and 50.</li> <li>Multiply the difference by 10 to get the penalty.</li> </ol>',
        };

        function loadContent(section) {
            document.getElementById('content').innerHTML = contentMap[section];
        }
    </script>

{% endblock %}
